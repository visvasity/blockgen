// Code generated by github.com/visvasity/blockgen. DO NOT EDIT.

package output

import (
	"fmt"
	"github.com/visvasity/blockgen/common"
	"iter"
	"sort"
	"strings"
)

// Reader type defines accessor methods for read-only access.
type RegionQueueDataBlock common.BlockBytes

// Writer type extends the reader with mutable methods.
type RegionQueueDataBlockWriter struct{ RegionQueueDataBlock }

// BlockBytes returns access to the underlying byte slice.
func (v RegionQueueDataBlock) BlockBytes() common.BlockBytes {
	return common.BlockBytes(v)
}

// Writer returns the RegionQueueDataBlock writer for read-write access to it's fields.
func (v RegionQueueDataBlock) Writer() RegionQueueDataBlockWriter {
	return RegionQueueDataBlockWriter{v}
}

// Reader returns the RegionQueueDataBlock reader with read-only access to it's fields.
func (v RegionQueueDataBlockWriter) Reader() RegionQueueDataBlock {
	return v.RegionQueueDataBlock
}

func (v RegionQueueDataBlock) IsZero() bool {
	return common.IsZero(v[:48])
}

func (v RegionQueueDataBlockWriter) SetZero() {
	common.SetZero(v.BlockBytes()[:48])
}

func (v RegionQueueDataBlock) String() string {
	var sb strings.Builder
	fmt.Fprintf(&sb, "NextLBA=%d", v.NextLBA())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "TestNumericValue={%v}", v.TestNumericValue())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "ValuesSlice=[:%d:%d]{", v.ValuesSliceLen(), v.ValuesSliceCap())
	for i := 0; i < v.ValuesSliceLen(); i++ {
		if i == 0 {
			fmt.Fprintf(&sb, "{%v}", v.ValuesSliceItemAt(i))
		} else {
			fmt.Fprintf(&sb, " {%v}", v.ValuesSliceItemAt(i))
		}
	}
	fmt.Fprintf(&sb, "}")
	return sb.String()
}

func (v RegionQueueDataBlock) NextLBA() LBA {
	return LBA(v.BlockBytes().Uint64At(0))
}

func (v RegionQueueDataBlockWriter) SetNextLBA(x LBA) {
	v.BlockBytes().SetUint64At(0, uint64(x))
}

func (v RegionQueueDataBlock) TestNumericValue() Region {
	return Region(v.BlockBytes()[8:])
}

func (v RegionQueueDataBlock) ValuesSliceLen() int {
	return int(v.BlockBytes().Int64At(32))
}

func (v RegionQueueDataBlock) ValuesSliceCap() int {
	return int(v.BlockBytes().Int64At(40))
}

func (v RegionQueueDataBlockWriter) internalSetValuesSliceLen(x int) {
	v.BlockBytes().SetInt64At(32, int64(x))
}

func (v RegionQueueDataBlockWriter) internalSetValuesSliceCap(x int) {
	v.BlockBytes().SetInt64At(40, int64(x))
}

func (v RegionQueueDataBlock) ValuesSliceItemAt(i int) Region {
	if i < 0 || i >= v.ValuesSliceLen() {
		panic(fmt.Sprintf("slice index %d is out of range [0:%d:%d]", i, v.ValuesSliceLen(), v.ValuesSliceCap()))
	}
	return Region(v[48+i*16:])
}

func (v RegionQueueDataBlockWriter) AppendValuesSlice() RegionWriter {
	n := v.ValuesSliceLen()
	if n == v.ValuesSliceCap() {
		panic(fmt.Sprintf("slice is already full with %d items", n))
	}
	v.internalSetValuesSliceLen(n + 1)
	return v.ValuesSliceItemAt(n).Writer()
}

func (v RegionQueueDataBlockWriter) CoalesceValuesSliceFunc(merge func(w RegionWriter, r Region) bool) int {
	nmerges := 0
	for i := 0; i < v.ValuesSliceLen()-1; {
		if merge(v.ValuesSliceItemAt(i).Writer(), v.ValuesSliceItemAt(i+1)) {
			v.RemoveValuesSliceItemAt(i + 1)
			nmerges++
			continue
		}
		i++
	}
	return nmerges
}

func (v RegionQueueDataBlockWriter) RemoveValuesSliceItemAt(i int) {
	n := v.ValuesSliceLen()
	if i < 0 || i >= n {
		panic(fmt.Sprintf("slice index %d is out of range [0:%d:%d]", i, v.ValuesSliceLen(), v.ValuesSliceCap()))
	}
	beg := 48 + i*16
	end := 48 + n*16
	copy(v.BlockBytes()[beg:], v.BlockBytes()[beg+16:end])
	common.SetZero(v.BlockBytes()[end-16 : end])
	v.internalSetValuesSliceLen(n - 1)
}

func (v RegionQueueDataBlockWriter) DeleteValuesSliceItems(i, j int) {
	n := v.ValuesSliceLen()
	if i < 0 || i >= n {
		panic(fmt.Sprintf("first slice index %d is out of range [0:%d:%d]", i, v.ValuesSliceLen(), v.ValuesSliceCap()))
	}
	if j < 0 || j >= n {
		panic(fmt.Sprintf("second slice index %d is out of range [0:%d:%d]", i, v.ValuesSliceLen(), v.ValuesSliceCap()))
	}
	if j < i {
		panic(fmt.Sprintf("invalid slice indices %d < %d", j, i))
	}
	if i == j {
		return
	}
	ioff := 48 + i*16
	joff := 48 + j*16
	end := 48 + n*16
	copy(v.BlockBytes()[ioff:end], v.BlockBytes()[joff:end])
	common.SetZero(v.BlockBytes()[end-(joff-ioff) : end])
	v.internalSetValuesSliceLen(n - (j - i))
}

func (v RegionQueueDataBlock) AllValuesSlice() iter.Seq2[int, Region] {
	return func(yield func(int, Region) bool) {
		for i := 0; i < v.ValuesSliceLen(); i++ {
			if !yield(i, v.ValuesSliceItemAt(i)) {
				return
			}
		}
	}
}

func (v RegionQueueDataBlockWriter) SwapValuesSliceItems(i, j int) {
	tmp := make([]byte, 16)
	ioff := 48 + i*16
	joff := 48 + j*16
	copy(tmp, v.BlockBytes()[ioff:ioff+16])
	copy(v.BlockBytes()[ioff:ioff+16], v.BlockBytes()[joff:joff+16])
	copy(v.BlockBytes()[joff:joff+16], tmp)
}

func (v RegionQueueDataBlockWriter) SortValuesSliceFunc(cmp func(a, b Region) int) {
	helper := common.SortHelper{
		LenFunc:     v.ValuesSliceLen,
		SwapFunc:    v.SwapValuesSliceItems,
		CompareFunc: func(i, j int) int { return cmp(v.ValuesSliceItemAt(i), v.ValuesSliceItemAt(j)) },
	}
	sort.Sort(&helper)
}

func (v RegionQueueDataBlock) FindValuesSliceFunc(cmp func(x Region) int) (int, bool) {
	return sort.Find(v.ValuesSliceLen(), func(i int) int { return cmp(v.ValuesSliceItemAt(i)) })
}

func RegionQueueDataBlockValuesSliceCapForNumBytes(nbytes int) int {
	return (nbytes - 48) / 16
}

// NewRegionQueueDataBlock creates a zero-initialized RegionQueueDataBlock. Returns nil if input block size is too small.
func NewRegionQueueDataBlock(block []byte) RegionQueueDataBlock {
	size := len(block)
	if size < 48 {
		return nil
	}
	common.SetZero(block)
	v := RegionQueueDataBlock(block)
	// RegionQueueDataBlock type has a slice field; we must set a cap on it.
	n := (size - 48) / 16
	v.Writer().internalSetValuesSliceCap(n)
	return v
}

func OpenRegionQueueDataBlock(block []byte) (RegionQueueDataBlock, error) {
	size := len(block)
	if size < 48 {
		return nil, fmt.Errorf("input size is too small")
	}
	v := RegionQueueDataBlock(block)
	// RegionQueueDataBlock type has a slice field; validate it's len and cap.
	n := (size - 48) / 16
	if x := v.ValuesSliceCap(); x != n {
		return nil, fmt.Errorf("slice field cap must be %d, found %d", n, x)
	}
	if x := v.ValuesSliceLen(); x < 0 || x > n {
		return nil, fmt.Errorf("slice field len is %d, must be between [%d-%d)", x, 0, n)
	}
	return v, nil
}
