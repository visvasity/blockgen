// Code generated by github.com/visvasity/blockgen. DO NOT EDIT.

package output

import (
	"fmt"
	"github.com/visvasity/blockgen/common"
	"iter"
	"sort"
	"strings"
)

// Reader type defines accessor methods for read-only access.
type SuperBlock common.BlockBytes

// Writer type extends the reader with mutable methods.
type SuperBlockWriter struct{ SuperBlock }

// BlockBytes returns access to the underlying byte slice.
func (v SuperBlock) BlockBytes() common.BlockBytes {
	return common.BlockBytes(v)
}

// Writer returns the SuperBlock writer for read-write access to it's fields.
func (v SuperBlock) Writer() SuperBlockWriter {
	return SuperBlockWriter{v}
}

// Reader returns the SuperBlock reader with read-only access to it's fields.
func (v SuperBlockWriter) Reader() SuperBlock {
	return v.SuperBlock
}

func (v SuperBlock) IsZero() bool {
	return common.IsZero(v[:248])
}

func (v SuperBlockWriter) SetZero() {
	common.SetZero(v.BlockBytes()[:248])
}

func (v SuperBlock) String() string {
	var sb strings.Builder
	fmt.Fprintf(&sb, "Header={%v}", v.Header())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "Options={%v}", v.Options())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "EndPBA=%d", v.EndPBA())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "MaxObjectID=%d", v.MaxObjectID())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "DBARegionList={%v}", v.DBARegionList())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "ObjectList={%v}", v.ObjectList())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "FreeDBAList={%v}", v.FreeDBAList())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "FreeDataRegionList={%v}", v.FreeDataRegionList())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "SyncedCacheLSN=%d", v.SyncedCacheLSN())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "JournalHeadOffset=%d", v.JournalHeadOffset())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "JournalTailOffset=%d", v.JournalTailOffset())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "JournalRegionSlice=[:%d:%d]{", v.JournalRegionSliceLen(), v.JournalRegionSliceCap())
	for i := 0; i < v.JournalRegionSliceLen(); i++ {
		if i == 0 {
			fmt.Fprintf(&sb, "{%v}", v.JournalRegionSliceItemAt(i))
		} else {
			fmt.Fprintf(&sb, " {%v}", v.JournalRegionSliceItemAt(i))
		}
	}
	fmt.Fprintf(&sb, "}")
	return sb.String()
}

func (v SuperBlock) Header() BlockHeader {
	return BlockHeader(v.BlockBytes()[0:])
}

func (v SuperBlock) Options() StorageOptions {
	return StorageOptions(v.BlockBytes()[48:])
}

func (v SuperBlock) EndPBA() PBA {
	return PBA(v.BlockBytes().Uint64At(88))
}

func (v SuperBlockWriter) SetEndPBA(x PBA) {
	v.BlockBytes().SetUint64At(88, uint64(x))
}

func (v SuperBlock) MaxObjectID() ObjectID {
	return ObjectID(v.BlockBytes().Int64At(96))
}

func (v SuperBlockWriter) SetMaxObjectID(x ObjectID) {
	v.BlockBytes().SetInt64At(96, int64(x))
}

func (v SuperBlock) DBARegionList() LinkedList {
	return LinkedList(v.BlockBytes()[104:])
}

func (v SuperBlock) ObjectList() LinkedList {
	return LinkedList(v.BlockBytes()[128:])
}

func (v SuperBlock) FreeDBAList() LinkedList {
	return LinkedList(v.BlockBytes()[152:])
}

func (v SuperBlock) FreeDataRegionList() LinkedList {
	return LinkedList(v.BlockBytes()[176:])
}

func (v SuperBlock) SyncedCacheLSN() LSN {
	return LSN(v.BlockBytes().Int64At(200))
}

func (v SuperBlockWriter) SetSyncedCacheLSN(x LSN) {
	v.BlockBytes().SetInt64At(200, int64(x))
}

func (v SuperBlock) JournalHeadOffset() int64 {
	return v.BlockBytes().Int64At(208)
}

func (v SuperBlockWriter) SetJournalHeadOffset(x int64) {
	v.BlockBytes().SetInt64At(208, x)
}

func (v SuperBlock) JournalTailOffset() int64 {
	return v.BlockBytes().Int64At(216)
}

func (v SuperBlockWriter) SetJournalTailOffset(x int64) {
	v.BlockBytes().SetInt64At(216, x)
}

func (v SuperBlock) JournalRegionSliceLen() int {
	return int(v.BlockBytes().Int64At(232))
}

func (v SuperBlock) JournalRegionSliceCap() int {
	return int(v.BlockBytes().Int64At(240))
}

func (v SuperBlockWriter) internalSetJournalRegionSliceLen(x int) {
	v.BlockBytes().SetInt64At(232, int64(x))
}

func (v SuperBlockWriter) internalSetJournalRegionSliceCap(x int) {
	v.BlockBytes().SetInt64At(240, int64(x))
}

func (v SuperBlock) JournalRegionSliceItemAt(i int) JournalRegion {
	if i < 0 || i >= v.JournalRegionSliceLen() {
		panic(fmt.Sprintf("slice index %d is out of range [0:%d:%d]", i, v.JournalRegionSliceLen(), v.JournalRegionSliceCap()))
	}
	return JournalRegion(v[248+i*24:])
}

func (v SuperBlockWriter) AppendJournalRegionSlice() JournalRegionWriter {
	n := v.JournalRegionSliceLen()
	if n == v.JournalRegionSliceCap() {
		panic(fmt.Sprintf("slice is already full with %d items", n))
	}
	v.internalSetJournalRegionSliceLen(n + 1)
	return v.JournalRegionSliceItemAt(n).Writer()
}

func (v SuperBlockWriter) CoalesceJournalRegionSliceFunc(merge func(w JournalRegionWriter, r JournalRegion) bool) int {
	nmerges := 0
	for i := 0; i < v.JournalRegionSliceLen()-1; {
		if merge(v.JournalRegionSliceItemAt(i).Writer(), v.JournalRegionSliceItemAt(i+1)) {
			v.RemoveJournalRegionSliceItemAt(i + 1)
			nmerges++
			continue
		}
		i++
	}
	return nmerges
}

func (v SuperBlockWriter) RemoveJournalRegionSliceItemAt(i int) {
	n := v.JournalRegionSliceLen()
	if i < 0 || i >= n {
		panic(fmt.Sprintf("slice index %d is out of range [0:%d:%d]", i, v.JournalRegionSliceLen(), v.JournalRegionSliceCap()))
	}
	beg := 248 + i*24
	end := 248 + n*24
	copy(v.BlockBytes()[beg:], v.BlockBytes()[beg+24:end])
	common.SetZero(v.BlockBytes()[end-24 : end])
	v.internalSetJournalRegionSliceLen(n - 1)
}

func (v SuperBlockWriter) DeleteJournalRegionSliceItems(i, j int) {
	n := v.JournalRegionSliceLen()
	if i < 0 || i >= n {
		panic(fmt.Sprintf("first slice index %d is out of range [0:%d:%d]", i, v.JournalRegionSliceLen(), v.JournalRegionSliceCap()))
	}
	if j < 0 || j >= n {
		panic(fmt.Sprintf("second slice index %d is out of range [0:%d:%d]", i, v.JournalRegionSliceLen(), v.JournalRegionSliceCap()))
	}
	if j < i {
		panic(fmt.Sprintf("invalid slice indices %d < %d", j, i))
	}
	if i == j {
		return
	}
	ioff := 248 + i*24
	joff := 248 + j*24
	end := 248 + n*24
	copy(v.BlockBytes()[ioff:end], v.BlockBytes()[joff:end])
	common.SetZero(v.BlockBytes()[end-(joff-ioff) : end])
	v.internalSetJournalRegionSliceLen(n - (j - i))
}

func (v SuperBlock) AllJournalRegionSlice() iter.Seq2[int, JournalRegion] {
	return func(yield func(int, JournalRegion) bool) {
		for i := 0; i < v.JournalRegionSliceLen(); i++ {
			if !yield(i, v.JournalRegionSliceItemAt(i)) {
				return
			}
		}
	}
}

func (v SuperBlockWriter) SwapJournalRegionSliceItems(i, j int) {
	tmp := make([]byte, 24)
	ioff := 248 + i*24
	joff := 248 + j*24
	copy(tmp, v.BlockBytes()[ioff:ioff+24])
	copy(v.BlockBytes()[ioff:ioff+24], v.BlockBytes()[joff:joff+24])
	copy(v.BlockBytes()[joff:joff+24], tmp)
}

func (v SuperBlockWriter) SortJournalRegionSliceFunc(cmp func(a, b JournalRegion) int) {
	helper := common.SortHelper{
		LenFunc:     v.JournalRegionSliceLen,
		SwapFunc:    v.SwapJournalRegionSliceItems,
		CompareFunc: func(i, j int) int { return cmp(v.JournalRegionSliceItemAt(i), v.JournalRegionSliceItemAt(j)) },
	}
	sort.Sort(&helper)
}

func (v SuperBlock) FindJournalRegionSliceFunc(cmp func(x JournalRegion) int) (int, bool) {
	return sort.Find(v.JournalRegionSliceLen(), func(i int) int { return cmp(v.JournalRegionSliceItemAt(i)) })
}

func SuperBlockJournalRegionSliceCapForNumBytes(nbytes int) int {
	return (nbytes - 248) / 24
}

// NewSuperBlock creates a zero-initialized SuperBlock. Returns nil if input block size is too small.
func NewSuperBlock(block []byte) SuperBlock {
	size := len(block)
	if size < 248 {
		return nil
	}
	common.SetZero(block)
	v := SuperBlock(block)
	// SuperBlock type has a slice field; we must set a cap on it.
	n := (size - 248) / 24
	v.Writer().internalSetJournalRegionSliceCap(n)
	return v
}

func OpenSuperBlock(block []byte) (SuperBlock, error) {
	size := len(block)
	if size < 248 {
		return nil, fmt.Errorf("input size is too small")
	}
	v := SuperBlock(block)
	// SuperBlock type has a slice field; validate it's len and cap.
	n := (size - 248) / 24
	if x := v.JournalRegionSliceCap(); x != n {
		return nil, fmt.Errorf("slice field cap must be %d, found %d", n, x)
	}
	if x := v.JournalRegionSliceLen(); x < 0 || x > n {
		return nil, fmt.Errorf("slice field len is %d, must be between [%d-%d)", x, 0, n)
	}
	return v, nil
}
