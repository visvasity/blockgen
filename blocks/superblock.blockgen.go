// Code generated by github.com/visvasity/blockgen. DO NOT EDIT.

package blocks

import (
	"fmt"
	"github.com/visvasity/blockgen/common"
	"iter"
	"sort"
	"strings"
)

// Reader type defines accessor methods for read-only access.
type SuperBlock common.BlockBytes

// Writer type extends the reader with mutable methods.
type SuperBlockWriter struct{ SuperBlock }

// BlockBytes returns access to the underlying byte slice.
func (v SuperBlock) BlockBytes() common.BlockBytes {
	return common.BlockBytes(v)
}

// Writer returns the SuperBlock writer for read-write access to it's fields.
func (v SuperBlock) Writer() SuperBlockWriter {
	return SuperBlockWriter{v}
}

// Reader returns the SuperBlock reader with read-only access to it's fields.
func (v SuperBlockWriter) Reader() SuperBlock {
	return v.SuperBlock
}

func (v SuperBlock) IsZero() bool {
	return common.IsZero(v[:248])
}

func (v SuperBlockWriter) SetZero() {
	common.SetZero(v.BlockBytes()[:248])
}

func (v SuperBlock) String() string {
	var sb strings.Builder
	fmt.Fprintf(&sb, "Header={%v}", v.Header())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "Options={%v}", v.Options())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "EndPBA=%d", v.EndPBA())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "MaxObjectID=%d", v.MaxObjectID())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "DBARegionList={%v}", v.DBARegionList())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "ObjectList={%v}", v.ObjectList())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "FreeDBAList={%v}", v.FreeDBAList())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "FreeDataRegionList={%v}", v.FreeDataRegionList())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "SyncedCacheLSN=%d", v.SyncedCacheLSN())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "JournalHeadOffset=%d", v.JournalHeadOffset())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "JournalTailOffset=%d", v.JournalTailOffset())
	fmt.Fprintf(&sb, " ")
	fmt.Fprintf(&sb, "JournalRegionList=[:%d:%d]{", v.JournalRegionListLen(), v.JournalRegionListCap())
	for i := 0; i < v.JournalRegionListLen(); i++ {
		if i == 0 {
			fmt.Fprintf(&sb, "{%v}", v.JournalRegionListItemAt(i))
		} else {
			fmt.Fprintf(&sb, " {%v}", v.JournalRegionListItemAt(i))
		}
	}
	fmt.Fprintf(&sb, "}")
	return sb.String()
}

func (v SuperBlock) Header() BlockHeader {
	return BlockHeader(v.BlockBytes()[0:])
}

func (v SuperBlock) Options() StorageOptions {
	return StorageOptions(v.BlockBytes()[48:])
}

func (v SuperBlock) EndPBA() PBA {
	return PBA(v.BlockBytes().Uint64At(88))
}

func (v SuperBlockWriter) SetEndPBA(x PBA) {
	v.BlockBytes().SetUint64At(88, uint64(x))
}

func (v SuperBlock) MaxObjectID() ObjectID {
	return ObjectID(v.BlockBytes().Int64At(96))
}

func (v SuperBlockWriter) SetMaxObjectID(x ObjectID) {
	v.BlockBytes().SetInt64At(96, int64(x))
}

func (v SuperBlock) DBARegionList() LinkedList {
	return LinkedList(v.BlockBytes()[104:])
}

func (v SuperBlock) ObjectList() LinkedList {
	return LinkedList(v.BlockBytes()[128:])
}

func (v SuperBlock) FreeDBAList() LinkedList {
	return LinkedList(v.BlockBytes()[152:])
}

func (v SuperBlock) FreeDataRegionList() LinkedList {
	return LinkedList(v.BlockBytes()[176:])
}

func (v SuperBlock) SyncedCacheLSN() LSN {
	return LSN(v.BlockBytes().Int64At(200))
}

func (v SuperBlockWriter) SetSyncedCacheLSN(x LSN) {
	v.BlockBytes().SetInt64At(200, int64(x))
}

func (v SuperBlock) JournalHeadOffset() int64 {
	return v.BlockBytes().Int64At(208)
}

func (v SuperBlockWriter) SetJournalHeadOffset(x int64) {
	v.BlockBytes().SetInt64At(208, x)
}

func (v SuperBlock) JournalTailOffset() int64 {
	return v.BlockBytes().Int64At(216)
}

func (v SuperBlockWriter) SetJournalTailOffset(x int64) {
	v.BlockBytes().SetInt64At(216, x)
}

func (v SuperBlock) JournalRegionListLen() int {
	return int(v.BlockBytes().Int64At(232))
}

func (v SuperBlock) JournalRegionListCap() int {
	return int(v.BlockBytes().Int64At(240))
}

func (v SuperBlockWriter) internalSetJournalRegionListLen(x int) {
	v.BlockBytes().SetInt64At(232, int64(x))
}

func (v SuperBlockWriter) internalSetJournalRegionListCap(x int) {
	v.BlockBytes().SetInt64At(240, int64(x))
}

func (v SuperBlock) JournalRegionListItemAt(i int) JournalRegion {
	if i < 0 || i >= v.JournalRegionListLen() {
		panic(fmt.Sprintf("slice index %d is out of range [0:%d:%d]", i, v.JournalRegionListLen(), v.JournalRegionListCap()))
	}
	return JournalRegion(v[248+i*24:])
}

func (v SuperBlockWriter) AppendJournalRegionList() JournalRegionWriter {
	n := v.JournalRegionListLen()
	if n == v.JournalRegionListCap() {
		panic(fmt.Sprintf("slice is already full with %d items", n))
	}
	v.internalSetJournalRegionListLen(n + 1)
	return v.JournalRegionListItemAt(n).Writer()
}

func (v SuperBlockWriter) CoalesceJournalRegionListFunc(merge func(w JournalRegionWriter, r JournalRegion) bool) int {
	nmerges := 0
	for i := 0; i < v.JournalRegionListLen()-1; {
		if merge(v.JournalRegionListItemAt(i).Writer(), v.JournalRegionListItemAt(i+1)) {
			v.RemoveJournalRegionListItemAt(i + 1)
			nmerges++
			continue
		}
		i++
	}
	return nmerges
}

func (v SuperBlockWriter) RemoveJournalRegionListItemAt(i int) {
	n := v.JournalRegionListLen()
	if i < 0 || i >= n {
		panic(fmt.Sprintf("slice index %d is out of range [0:%d:%d]", i, v.JournalRegionListLen(), v.JournalRegionListCap()))
	}
	beg := 248 + i*24
	end := 248 + n*24
	copy(v.BlockBytes()[beg:], v.BlockBytes()[beg+24:end])
	common.SetZero(v.BlockBytes()[end-24 : end])
	v.internalSetJournalRegionListLen(n - 1)
}

func (v SuperBlock) AllJournalRegionList() iter.Seq2[int, JournalRegion] {
	return func(yield func(int, JournalRegion) bool) {
		for i := 0; i < v.JournalRegionListLen(); i++ {
			if !yield(i, v.JournalRegionListItemAt(i)) {
				return
			}
		}
	}
}

func (v SuperBlockWriter) SwapJournalRegionListItems(i, j int) {
	tmp := make([]byte, 24)
	ioff := 248 + i*24
	joff := 248 + j*24
	copy(tmp, v.BlockBytes()[ioff:ioff+24])
	copy(v.BlockBytes()[ioff:ioff+24], v.BlockBytes()[joff:joff+24])
	copy(v.BlockBytes()[joff:joff+24], tmp)
}

func (v SuperBlockWriter) SortJournalRegionListFunc(cmp func(a, b JournalRegion) int) {
	helper := common.SortHelper{
		LenFunc:     v.JournalRegionListLen,
		SwapFunc:    v.SwapJournalRegionListItems,
		CompareFunc: func(i, j int) int { return cmp(v.JournalRegionListItemAt(i), v.JournalRegionListItemAt(j)) },
	}
	sort.Sort(&helper)
}

func (v SuperBlock) FindJournalRegionListFunc(cmp func(x JournalRegion) int) (int, bool) {
	return sort.Find(v.JournalRegionListLen(), func(i int) int { return cmp(v.JournalRegionListItemAt(i)) })
}

func SuperBlockJournalRegionListCapForNumBytes(nbytes int) int {
	return (nbytes - 248) / 24
}

// NewSuperBlock creates a zero-initialized SuperBlock. Returns nil if input block size is too small.
func NewSuperBlock(block []byte) SuperBlock {
	size := len(block)
	if size < 248 {
		return nil
	}
	common.SetZero(block)
	v := SuperBlock(block)
	// SuperBlock type has a slice field; we must set a cap on it.
	n := (size - 248) / 24
	v.Writer().internalSetJournalRegionListCap(n)
	return v
}

func OpenSuperBlock(block []byte) (SuperBlock, error) {
	size := len(block)
	if size < 248 {
		return nil, fmt.Errorf("input size is too small")
	}
	v := SuperBlock(block)
	// SuperBlock type has a slice field; validate it's len and cap.
	n := (size - 248) / 24
	if x := v.JournalRegionListCap(); x != n {
		return nil, fmt.Errorf("slice field cap must be %d, found %d", n, x)
	}
	if x := v.JournalRegionListLen(); x < 0 || x > n {
		return nil, fmt.Errorf("slice field len is %d, must be between [%d-%d)", x, 0, n)
	}
	return v, nil
}
